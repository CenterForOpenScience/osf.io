# -*- coding: utf-8 -*-
import urlparse

from dirtyfields import DirtyFieldsMixin
from django.db import models, transaction
from django.utils import timezone
from django.utils.functional import cached_property
from django.contrib.contenttypes.fields import GenericRelation
from django.core.exceptions import ValidationError

from framework.postcommit_tasks.handlers import enqueue_postcommit_task
from framework import status
from framework.exceptions import PermissionsError
from osf.models import NodeLog, Subject, Tag, OSFUser
from osf.models.contributor import PreprintContributor, RecentlyAddedContributor
from osf.models.mixins import ReviewableMixin, Taggable, Loggable, GuardianMixin
from osf.models.validators import validate_subject_hierarchy, validate_title
from osf.utils.fields import NonNaiveDateTimeField
from osf.utils.workflows import DefaultStates
from osf.utils import sanitize
from website.preprints.tasks import on_preprint_updated, get_and_set_preprint_identifiers
from website.project.licenses import set_license
from website.util import api_v2_url
from website import settings, mails

from osf.models.base import BaseModel, GuidMixin
from osf.models.identifiers import IdentifierMixin, Identifier

from framework.auth.core import get_user
from website.project import signals as project_signals
from osf.exceptions import (
    PreprintStateError, ValidationValueError, InvalidTagError, TagNotFoundError
)


class PreprintService(DirtyFieldsMixin, GuidMixin, IdentifierMixin, ReviewableMixin, BaseModel, Loggable, Taggable, GuardianMixin):
    provider = models.ForeignKey('osf.PreprintProvider',
                                 on_delete=models.SET_NULL,
                                 related_name='preprint_services',
                                 null=True, blank=True, db_index=True)
    node = models.ForeignKey('osf.AbstractNode', on_delete=models.SET_NULL,
                             related_name='preprints',
                             null=True, blank=True, db_index=True)
    is_published = models.BooleanField(default=False, db_index=True)
    date_published = NonNaiveDateTimeField(null=True, blank=True)
    original_publication_date = NonNaiveDateTimeField(null=True, blank=True)
    license = models.ForeignKey('osf.NodeLicenseRecord',
                                on_delete=models.SET_NULL, null=True, blank=True)

    subjects = models.ManyToManyField(blank=True, to='osf.Subject', related_name='preprint_services')

    identifiers = GenericRelation(Identifier, related_query_name='preprintservices')
    preprint_doi_created = NonNaiveDateTimeField(default=None, null=True, blank=True)
    # begin changes
    title = models.TextField(
        validators=[validate_title]
    )  # this should be a charfield but data from mongo didn't fit in 255
    description = models.TextField(blank=True, default='')
    creator = models.ForeignKey(OSFUser,
                                db_index=True,
                                related_name='preprints_created',
                                on_delete=models.SET_NULL,
                                null=True, blank=True)
    _contributors = models.ManyToManyField(OSFUser,
                                           through=PreprintContributor,
                                           related_name='preprints')

    groups = {
        'read': ('read_preprint',),
        'write': ('read_preprint', 'write_preprint',),
        'admin': ('read_preprint', 'write_preprint', 'admin_preprint',)
    }
    group_format = 'preprint_{self.id}_{group}'

    class Meta:
        unique_together = ('node', 'provider')
        permissions = (
            ('osf_admin_view_preprint', 'Can view preprint service details in the admin app.'),
            ('read_preprint', 'Can read the preprint'),
            ('write_preprint', 'Can write the preprint'),
            ('admin_preprint', 'Can manage the preprint'),
        )

    def __unicode__(self):
        return '{} preprint (guid={}) of {}'.format('published' if self.is_published else 'unpublished', self._id, self.node.__unicode__() if self.node else None)

    @property
    def contributors(self):
        # NOTE: _order field is generated by order_with_respect_to = 'node'
        return self._contributors.order_by('contributor___order')

    @property
    def verified_publishable(self):
        return self.is_published and self.node.is_preprint and not self.node.is_deleted

    @property
    def primary_file(self):
        if not self.node:
            return
        return self.node.preprint_file

    @property
    def article_doi(self):
        if not self.node:
            return
        return self.node.preprint_article_doi

    @property
    def preprint_doi(self):
        return self.get_identifier_value('doi')

    @property
    def is_preprint_orphan(self):
        if not self.node:
            return
        return self.node.is_preprint_orphan

    @cached_property
    def subject_hierarchy(self):
        return [
            s.object_hierarchy for s in self.subjects.exclude(children__in=self.subjects.all())
        ]

    @property
    def deep_url(self):
        # Required for GUID routing
        return '/preprints/{}/'.format(self._primary_key)

    @property
    def url(self):
        if (self.provider.domain_redirect_enabled and self.provider.domain) or self.provider._id == 'osf':
            return '/{}/'.format(self._id)

        return '/preprints/{}/{}/'.format(self.provider._id, self._id)

    @property
    def absolute_url(self):
        return urlparse.urljoin(
            self.provider.domain if self.provider.domain_redirect_enabled else settings.DOMAIN,
            self.url
        )

    @property
    def absolute_api_v2_url(self):
        path = '/preprints/{}/'.format(self._id)
        return api_v2_url(path)

    def has_permission(self, user, permission):
        """Check whether user has permission.
        :param User user: User to test
        :param str permission: Required permission
        :returns: User has required permission
        """
        if not user:
            return False
        return self.get_group(permission).filter(user_id=user.id).exists()

    def set_permissions(self, user, permission, validate=True, save=False):
        # Ensure that user's permissions cannot be lowered if they are the only admin
        if isinstance(user, PreprintContributor):
            user = user.user

        if validate and (self.has_permission(user, 'admin') and 'admin' not in permission):
            if self.get_group('admin').user_set.count() <= 1:
                raise PreprintStateError('Must have at least one registered admin contributor')
        self.clear_permissions(user)
        self.add_permission(user, permission)
        if save:
            self.save()

    def get_subjects(self):
        ret = []
        for subj_list in self.subject_hierarchy:
            subj_hierarchy = []
            for subj in subj_list:
                if subj:
                    subj_hierarchy += ({'id': subj._id, 'text': subj.text}, )
            if subj_hierarchy:
                ret.append(subj_hierarchy)
        return ret

    def set_subjects(self, preprint_subjects, auth):
        if not self.has_permission(auth.user, 'admin'):
            raise PermissionsError('Only admins can change a preprint\'s subjects.')

        old_subjects = list(self.subjects.values_list('id', flat=True))
        self.subjects.clear()
        for subj_list in preprint_subjects:
            subj_hierarchy = []
            for s in subj_list:
                subj_hierarchy.append(s)
            if subj_hierarchy:
                validate_subject_hierarchy(subj_hierarchy)
                for s_id in subj_hierarchy:
                    self.subjects.add(Subject.load(s_id))

        self.save(old_subjects=old_subjects)

    def set_primary_file(self, preprint_file, auth, save=False):
        if not self.has_permission(auth.user, 'admin'):
            raise PermissionsError('Only admins can change a preprint\'s primary file.')

        if preprint_file.node != self.node or preprint_file.provider != 'osfstorage':
            raise ValueError('This file is not a valid primary file for this preprint.')

        existing_file = self.node.preprint_file
        self.node.preprint_file = preprint_file

        # only log if updating the preprint file, not adding for the first time
        if existing_file:
            self.node.add_log(
                action=NodeLog.PREPRINT_FILE_UPDATED,
                params={
                    'preprint': self._id
                },
                auth=auth,
                save=False
            )

        if save:
            self.save()
            self.node.save()

    def set_published(self, published, auth, save=False):
        if not self.has_permission(auth.user, 'admin'):
            raise PermissionsError('Only admins can publish a preprint.')

        if self.is_published and not published:
            raise ValueError('Cannot unpublish preprint.')

        self.is_published = published

        if published:
            if not (self.node.preprint_file and self.node.preprint_file.node == self.node):
                raise ValueError('Preprint node is not a valid preprint; cannot publish.')
            if not self.provider:
                raise ValueError('Preprint provider not specified; cannot publish.')
            if not self.subjects.exists():
                raise ValueError('Preprint must have at least one subject to be published.')
            self.date_published = timezone.now()
            self.node._has_abandoned_preprint = False

            # In case this provider is ever set up to use a reviews workflow, put this preprint in a sensible state
            self.machine_state = DefaultStates.ACCEPTED.value
            self.date_last_transitioned = self.date_published

            self.node.add_log(
                action=NodeLog.PREPRINT_INITIATED,
                params={
                    'preprint': self._id
                },
                auth=auth,
                save=False,
            )

            if not self.node.is_public:
                self.node.set_privacy(
                    self.node.PUBLIC,
                    auth=None,
                    log=True
                )

            # This should be called after all fields for EZID metadta have been set
            enqueue_postcommit_task(get_and_set_preprint_identifiers, (), {'preprint_id': self._id}, celery=True)

            self._send_preprint_confirmation(auth)

        if save:
            self.node.save()
            self.save()

    def set_preprint_license(self, license_detail, auth, save=False):
        license_record, license_changed = set_license(self, license_detail, auth, node_type='preprint')

        if license_changed:
            self.node.add_log(
                action=NodeLog.PREPRINT_LICENSE_UPDATED,
                params={
                    'preprint': self._id,
                    'new_license': license_record.node_license.name
                },
                auth=auth,
                save=False
            )

        if save:
            self.save()

    def set_identifier_values(self, doi, save=False):
        self.set_identifier_value('doi', doi)
        self.preprint_doi_created = timezone.now()

        if save:
            self.save()

    def save(self, *args, **kwargs):
        first_save = not bool(self.pk)
        saved_fields = self.get_dirty_fields() or []
        old_subjects = kwargs.pop('old_subjects', [])
        ret = super(PreprintService, self).save(*args, **kwargs)

        if (not first_save and 'is_published' in saved_fields) or self.is_published:
            enqueue_postcommit_task(on_preprint_updated, (self._id,), {'old_subjects': old_subjects}, celery=True)

        if first_save:
            self.update_group_permissions()
            self.get_group('admin').user_set.add(self.creator)

        return ret

    def _send_preprint_confirmation(self, auth):
        # Send creator confirmation email
        if self.provider._id == 'osf':
            email_template = getattr(mails, 'PREPRINT_CONFIRMATION_DEFAULT')
        else:
            email_template = getattr(mails, 'PREPRINT_CONFIRMATION_BRANDED')(self.provider)

        mails.send_mail(
            auth.user.username,
            email_template,
            user=auth.user,
            node=self.node,
            preprint=self,
            osf_contact_email=settings.OSF_CONTACT_EMAIL,
        )

    # FOLLOWING BEHAVIOR NOT SPECIFIC TO PREPRINTS

    # visible_contributor_ids was moved to this property
    @property
    def visible_contributor_ids(self):
        return self.preprintcontributor_set.filter(visible=True) \
            .order_by('_order') \
            .values_list('user__guids___id', flat=True)

    @property
    def all_tags(self):
        """Return a queryset containing all of this node's tags (incl. system tags)."""
        # Tag's default manager only returns non-system tags, so we can't use self.tags
        return Tag.all_tags.filter(abstractnode_tagged=self)

    @property
    def system_tags(self):
        """The system tags associated with this node. This currently returns a list of string
        names for the tags, for compatibility with v1. Eventually, we can just return the
        QuerySet.
        """
        return self.all_tags.filter(system=True).values_list('name', flat=True)

    # Override Taggable
    def add_tag_log(self, tag, auth):
        # self.add_log(
        #     action=NodeLog.TAG_ADDED,
        #     params={
        #         'parent_node': self.parent_id,
        #         'node': self._id,
        #         'tag': tag.name
        #     },
        #     auth=auth,
        #     save=False
        # )
        pass

    # Override Taggable
    def on_tag_added(self, tag):
        # self.update_search()  # TODO: uncomment this
        pass

    def remove_tag(self, tag, auth, save=True):
        if not tag:
            raise InvalidTagError
        elif not self.tags.filter(name=tag).exists():
            raise TagNotFoundError
        else:
            tag_obj = Tag.objects.get(name=tag)
            self.tags.remove(tag_obj)
            # self.add_log(
            #     action=NodeLog.TAG_REMOVED,
            #     params={
            #         'parent_node': self.parent_id,
            #         'node': self._id,
            #         'tag': tag,
            #     },
            #     auth=auth,
            #     save=False,
            # )
            if save:
                self.save()
            # self.update_search()  # TODO: uncomment this
            return True

    def is_contributor(self, user):
        """Return whether ``user`` is a contributor on this node."""
        return user is not None and PreprintContributor.objects.filter(user=user, preprint=self).exists()

    def add_contributor(self, contributor, permission=None, visible=True,
                        send_email='default', auth=None, log=True, save=False):
        """Add a contributor to the project.

        :param User contributor: The contributor to be added
        :param list permissions: Permissions to grant to the contributor
        :param bool visible: PreprintContributor is visible in project dashboard
        :param str send_email: Email preference for notifying added contributor
        :param Auth auth: All the auth information including user, API key
        :param bool log: Add log to self
        :param bool save: Save after adding contributor
        :returns: Whether contributor was added
        """
        MAX_RECENT_LENGTH = 15

        # If user is merged into another account, use master account
        contrib_to_add = contributor.merged_by if contributor.is_merged else contributor
        if contrib_to_add.is_disabled:
            raise ValidationValueError('Deactivated users cannot be added as contributors.')

        if not self.is_contributor(contrib_to_add):

            contributor_obj, created = PreprintContributor.objects.get_or_create(user=contrib_to_add, preprint=self)
            contributor_obj.visible = visible
            if not permission:
                permission = 'write'
            self.add_permission(contrib_to_add, permission, save=True)

            contributor.save()

            # Add contributor to recently added list for user
            if auth is not None:
                user = auth.user
                recently_added_contributor_obj, created = RecentlyAddedContributor.objects.get_or_create(
                    user=user,
                    contributor=contrib_to_add
                )
                recently_added_contributor_obj.date_added = timezone.now()
                recently_added_contributor_obj.save()
                count = user.recently_added.count()
                if count > MAX_RECENT_LENGTH:
                    difference = count - MAX_RECENT_LENGTH
                    for each in user.recentlyaddedcontributor_set.order_by('date_added')[:difference]:
                        each.delete()
            # if log:
            #     self.add_log(
            #         action=NodeLog.CONTRIB_ADDED,
            #         params={
            #             'project': self.parent_id,
            #             'node': self._primary_key,
            #             'contributors': [contrib_to_add._primary_key],
            #         },
            #         auth=auth,
            #         save=False,
            #     )
            if save:
                self.save()

            # self.update_search()  # TODO: uncomment this
            return contrib_to_add, True

        # Permissions must be overridden if changed when contributor is
        # added to parent he/she is already on a child of.
        elif self.is_contributor(contrib_to_add) and permission is not None:
            self.set_permissions(contrib_to_add, permission)
            if save:
                self.save()

            return False
        else:
            return False

    def add_contributors(self, contributors, auth=None, log=True, save=False):
        """Add multiple contributors

        :param list contributors: A list of dictionaries of the form:
            {
                'user': <User object>,
                'permissions': <Permissions list, e.g. ['read', 'write']>,
                'visible': <Boolean indicating whether or not user is a bibliographic contributor>
            }
        :param auth: All the auth information including user, API key.
        :param log: Add log to self
        :param save: Save after adding contributor
        """
        for contrib in contributors:
            self.add_contributor(
                contributor=contrib['user'], permission=contrib['permissions'],
                visible=contrib['visible'], auth=auth, log=False, save=False,
            )
        # if log and contributors:
        #     self.add_log(
        #         action=NodeLog.CONTRIB_ADDED,
        #         params={
        #             'project': self.parent_id,
        #             'node': self._primary_key,
        #             'contributors': [
        #                 contrib['user']._id
        #                 for contrib in contributors
        #             ],
        #         },
        #         auth=auth,
        #         save=False,
        #     )
        if save:
            self.save()

    def add_unregistered_contributor(self, fullname, email, auth, send_email='default',
                                     visible=True, permission=None, save=False, existing_user=None):
        """Add a non-registered contributor to the project.

        :param str fullname: The full name of the person.
        :param str email: The email address of the person.
        :param Auth auth: Auth object for the user adding the contributor.
        :param User existing_user: the unregister_contributor if it is already created, otherwise None
        :returns: The added contributor
        :raises: DuplicateEmailError if user with given email is already in the database.
        """
        # Create a new user record if you weren't passed an existing user
        contributor = existing_user if existing_user else OSFUser.create_unregistered(fullname=fullname, email=email)

        contributor.add_unclaimed_record(node=self, referrer=auth.user,
                                         given_name=fullname, email=email)
        try:
            contributor.save()
        except ValidationError:  # User with same email already exists
            contributor = get_user(email=email)
            # Unregistered users may have multiple unclaimed records, so
            # only raise error if user is registered.
            if contributor.is_registered or self.is_contributor(contributor):
                raise

            contributor.add_unclaimed_record(
                node=self, referrer=auth.user, given_name=fullname, email=email
            )

            contributor.save()

        self.add_contributor(
            contributor, permission=permission, auth=auth,
            visible=visible, send_email=send_email, log=True, save=False
        )
        self.save()
        return contributor

    def add_contributor_registered_or_not(self, auth, user_id=None,
                                          full_name=None, email=None, send_email='false',
                                          permission=None, bibliographic=True, index=None, save=False):

        if user_id:
            contributor = OSFUser.load(user_id)
            if not contributor:
                raise ValueError('User with id {} was not found.'.format(user_id))
            if not contributor.is_registered:
                raise ValueError(
                    'Cannot add unconfirmed user {} to node {} by guid. Add an unregistered contributor with fullname and email.'
                    .format(user_id, self._id)
                )
            if self.preprintcontributor_set.filter(user=contributor).exists():
                raise ValidationValueError('{} is already a contributor.'.format(contributor.fullname))
            contributor, _ = self.add_contributor(contributor=contributor, auth=auth, visible=bibliographic,
                                 permission=permission, send_email=send_email, save=True)
        else:

            try:
                contributor = self.add_unregistered_contributor(
                    fullname=full_name, email=email, auth=auth,
                    send_email=send_email, permission=permission,
                    visible=bibliographic, save=True
                )
            except ValidationError:
                contributor = get_user(email=email)
                if self.preprintcontributor_set.filter(user=contributor).exists():
                    raise ValidationValueError('{} is already a contributor.'.format(contributor.fullname))
                self.add_contributor(contributor=contributor, auth=auth, visible=bibliographic,
                                     send_email=send_email, permission=permission, save=True)

        auth.user.email_last_sent = timezone.now()
        auth.user.save()

        if index is not None:
            self.move_contributor(contributor=contributor, index=index, auth=auth, save=True)

        contributor_obj = self.preprintcontributor_set.get(user=contributor)
        contributor.bibliographic = contributor_obj.visible
        contributor.node_id = self._id
        contributor_order = list(self.get_preprintcontributor_order())
        contributor.index = contributor_order.index(contributor_obj.pk)

        if save:
            contributor.save()

        return contributor_obj

    def set_visible(self, user, visible, log=True, auth=None, save=False):
        if not self.is_contributor(user):
            raise ValueError(u'User {0} not in contributors'.format(user))

        if visible and not PreprintContributor.objects.filter(preprint=self, user=user, visible=True).exists():
            PreprintContributor.objects.filter(preprint=self, user=user, visible=False).update(visible=True)
        elif not visible and PreprintContributor.objects.filter(preprintservice=self, user=user, visible=True).exists():
            if PreprintContributor.objects.filter(preprint=self, visible=True).count() == 1:
                raise ValueError('Must have at least one visible contributor')
            PreprintContributor.objects.filter(preprint=self, user=user, visible=True).update(visible=False)
        else:
            return
        # todo: implement preprint log
        # message = (
        # NodeLog.MADE_CONTRIBUTOR_VISIBLE
        # if visible
        # else NodeLog.MADE_CONTRIBUTOR_INVISIBLE
        # )
        # if log:
        # self.add_log(
        # message,
        # params={
        # 'parent': self.parent_id,
        # 'node': self._id,
        # 'contributors': [user._id],
        # },
        # auth=auth,
        # save=False,
        # )
        if save:
            self.save()

    def replace_contributor(self, old, new):
        try:
            contrib_obj = self.preprintcontributor_set.get(user=old)
        except PreprintContributor.DoesNotExist:
            return False
        contrib_obj.user = new
        contrib_obj.save()
        for group_name in self.group_names:
            if self.get_group(group_name).user_set.filter(user=old).exists():
                self.get_group(group_name).user_set.remove(old)
                self.get_group(group_name).user_set.add(new)

        # Remove unclaimed record for the project
        if self._id in old.unclaimed_records:
            del old.unclaimed_records[self._id]
            old.save()
        return True

    def remove_contributor(self, contributor, auth, log=True):
        """Remove a contributor from this node.

        :param contributor: User object, the contributor to be removed
        :param auth: All the auth information including user, API key.
        """

        if isinstance(contributor, PreprintContributor):
            contributor = contributor.user

        # remove unclaimed record if necessary
        if self._id in contributor.unclaimed_records:
            del contributor.unclaimed_records[self._id]
            contributor.save()

        # If user is the only visible contributor, return False
        if not self.preprintcontributor_set.exclude(user=contributor).filter(visible=True).exists():
            return False

        # Node must have at least one registered admin user
        if not self.get_group('admin').user_set.exclude(id=contributor.id).exists():
            return False

        contrib_obj = self.preprintcontributor_set.get(user=contributor)
        contrib_obj.delete()
        self.clear_permissions(contributor)

        # After remove callback
        for addon in self.get_addons():
            message = addon.after_remove_contributor(self, contributor, auth)
            if message:
                # Because addons can return HTML strings, addons are responsible
                # for markupsafe-escaping any messages returned
                status.push_status_message(message, kind='info', trust=True)

        # if log:
        #     self.add_log(
        #         action=NodeLog.CONTRIB_REMOVED,
        #         params={
        #             'project': self.parent_id,
        #             'node': self._id,
        #             'contributors': [contributor._id],
        #         },
        #         auth=auth,
        #         save=False,
        #     )

        self.save()
        # self.update_search()  # TODO: uncomment this
        # send signal to remove this user from project subscriptions
        project_signals.contributor_removed.send(self, user=contributor)

        # self.save_node_preprints()  # TODO: decide what to do with this
        return True

    def remove_contributors(self, contributors, auth=None, log=True, save=False):

        results = []
        removed = []

        for contrib in contributors:
            outcome = self.remove_contributor(
                contributor=contrib, auth=auth, log=False,
            )
            results.append(outcome)
            removed.append(contrib._id)
        # if log:
        #     self.add_log(
        #         action=NodeLog.CONTRIB_REMOVED,
        #         params={
        #             'project': self.parent_id,
        #             'node': self._primary_key,
        #             'contributors': removed,
        #         },
        #         auth=auth,
        #         save=False,
        #     )

        if save:
            self.save()

        return all(results)

    def move_contributor(self, contributor, auth, index, save=False):
        if not self.has_permission(auth.user, 'admin'):
            raise PermissionsError('Only admins can modify contributor order')
        if isinstance(contributor, OSFUser):
            contributor = self.preprintcontributor_set.get(user=contributor)
        contributor_ids = list(self.get_preprintcontributor_order())
        old_index = contributor_ids.index(contributor.id)
        contributor_ids.insert(index, contributor_ids.pop(old_index))
        self.set_contributor_order(contributor_ids)
        # self.add_log(
        #     action=NodeLog.CONTRIB_REORDERED,
        #     params={
        #         'project': self.parent_id,
        #         'node': self._id,
        #         'contributors': [
        #             contributor.user._id
        #         ],
        #     },
        #     auth=auth,
        #     save=False,
        # )
        if save:
            self.save()
        # self.save_node_preprints()  # TODO: decide what to do with this

    def active_contributors(self, include=lambda n: True):
        for contrib in self.contributors.filter(is_active=True):
            if include(contrib):
                yield contrib

    def get_admin_contributors(self, users):
        """Return a set of all admin contributors for this node. Excludes contributors on node links and
        inactive users.
        """
        return (each.user for each in self.get_group('admin').user_set)


    # TODO: Optimize me
    def manage_contributors(self, user_dicts, auth, save=False):
        """Reorder and remove contributors.

        :param list user_dicts: Ordered list of contributors represented as
            dictionaries of the form:
            {'id': <id>, 'permission': <One of 'read', 'write', 'admin'>, 'visible': bool}
        :param Auth auth: Consolidated authentication information
        :param bool save: Save changes
        :raises: ValueError if any users in `users` not in contributors or if
            no admin contributors remaining
        """
        with transaction.atomic():
            users = []
            user_ids = []
            permissions_changed = {}
            visibility_removed = []
            to_retain = []
            to_remove = []
            for user_dict in user_dicts:
                user = OSFUser.load(user_dict['id'])
                if user is None:
                    raise ValueError('User not found')
                if not self.contributors.filter(id=user.id).exists():
                    raise ValueError(
                        'User {0} not in contributors'.format(user.fullname)
                    )
                permission = user_dict['permission']
                if not self.get_group(permission).filter(user_id=user.id).exists():
                    # Validate later
                    self.set_permissions(user, permission, validate=False, save=False)
                    permissions_changed[user._id] = permission
                # visible must be added before removed to ensure they are validated properly
                if user_dict['visible']:
                    self.set_visible(user,
                                     visible=True,
                                     auth=auth)
                else:
                    visibility_removed.append(user)
                users.append(user)
                user_ids.append(user_dict['id'])

            for user in visibility_removed:
                self.set_visible(user,
                                 visible=False,
                                 auth=auth)

            for user in self.contributors.all():
                if user._id in user_ids:
                    to_retain.append(user)
                else:
                    to_remove.append(user)

            if users is None or not self.get_group('admin').user_set.count() < 1:
                raise PreprintStateError(
                    'Must have at least one registered admin contributor'
                )

            if to_retain != users:
                # Ordered Contributor PKs, sorted according to the passed list of user IDs
                sorted_contrib_ids = [
                    each.id for each in sorted(self.preprintcontributor_set.all(), key=lambda c: user_ids.index(c.user._id))
                ]
                self.set_contributor_order(sorted_contrib_ids)
                # self.add_log(
                #     action=NodeLog.CONTRIB_REORDERED,
                #     params={
                #         'project': self.parent_id,
                #         'node': self._id,
                #         'contributors': [
                #             user._id
                #             for user in users
                #         ],
                #     },
                #     auth=auth,
                #     save=False,
                # )

            if to_remove:
                self.remove_contributors(to_remove, auth=auth, save=False)

            # if permissions_changed:
            #     self.add_log(
            #         action=NodeLog.PERMISSIONS_UPDATED,
            #         params={
            #             'project': self.parent_id,
            #             'node': self._id,
            #             'contributors': permissions_changed,
            #         },
            #         auth=auth,
            #         save=False,
            #     )
            if save:
                self.save()

            # self.save_node_preprints()  # TODO: decide what to do with this

        with transaction.atomic():
            if to_remove or permissions_changed and ['read'] in permissions_changed.values():
                project_signals.write_permissions_revoked.send(self)

    # TODO: optimize me
    def update_contributor(self, user, permission, visible, auth, save=False):
        """ TODO: this method should be updated as a replacement for the main loop of
        Node#manage_contributors. Right now there are redundancies, but to avoid major
        feature creep this will not be included as this time.

        Also checks to make sure unique admin is not removing own admin privilege.
        """
        if not self.has_permission(auth.user, 'admin'):
            raise PermissionsError('Only admins can modify contributor permissions')

        if permission:
            admin_list = self.get_group('admin').user_set
            if not admin_list.count() > 1:
                # has only one admin
                admin = admin_list.first()
                if admin.user == user and 'admin' not in permission:
                    raise PreprintStateError('{} is the only admin.'.format(user.fullname))
            if not self.preprintcontributor_set.filter(user=user).exists():
                raise ValueError(
                    'User {0} not in contributors'.format(user.fullname)
                )
            if not self.get_group(permission).filter(user_id=user.id).exists():
                self.set_permissions(user, permission, save=save)
                permissions_changed = {
                    user._id: permission
                }
                # self.add_log(
                #     action=NodeLog.PERMISSIONS_UPDATED,
                #     params={
                #         'project': self.parent_id,
                #         'node': self._id,
                #         'contributors': permissions_changed,
                #     },
                #     auth=auth,
                #     save=save
                # )
                with transaction.atomic():
                    if ['read'] in permissions_changed.values():
                        project_signals.write_permissions_revoked.send(self)
        if visible is not None:
            self.set_visible(user, visible, auth=auth)
            # self.save_node_preprints()  # TODO: decide what to do with this


    def set_title(self, title, auth, save=False):
        """Set the title of this Node and log it.

        :param str title: The new title.
        :param auth: All the auth information including user, API key.
        """
        # Called so validation does not have to wait until save.
        validate_title(title)

        original_title = self.title
        new_title = sanitize.strip_html(title)
        # Title hasn't changed after sanitzation, bail out
        if original_title == new_title:
            return False
        self.title = new_title
        # self.add_log(
        #     action=NodeLog.EDITED_TITLE,
        #     params={
        #         'parent_node': self.parent_id,
        #         'node': self._primary_key,
        #         'title_new': self.title,
        #         'title_original': original_title,
        #     },
        #     auth=auth,
        #     save=False,
        # )
        if save:
            self.save()
        return None

    def set_description(self, description, auth, save=False):
        """Set the description and log the event.

        :param str description: The new description
        :param auth: All the auth informtion including user, API key.
        :param bool save: Save self after updating.
        """
        original = self.description
        new_description = sanitize.strip_html(description)
        if original == new_description:
            return False
        self.description = new_description
        # self.add_log(
        #     action=NodeLog.EDITED_DESCRIPTION,
        #     params={
        #         'parent_node': self.parent_id,
        #         'node': self._primary_key,
        #         'description_new': self.description,
        #         'description_original': original
        #     },
        #     auth=auth,
        #     save=False,
        # )
        if save:
            self.save()
        return None

    def can_view(self, auth):
        if not auth and not self.is_published:
            return False

        return self.is_published or (auth.user and self.has_permission(auth.user, 'read'))

    def can_edit(self, auth=None, user=None):
        """Return if a user is authorized to edit this node.
        Must specify one of (`auth`, `user`).

        :param Auth auth: Auth object to check
        :param User user: User object to check
        :returns: Whether user has permission to edit this node.
        """
        if not auth and not user:
            raise ValueError('Must pass either `auth` or `user`')
        if auth and user:
            raise ValueError('Cannot pass both `auth` and `user`')
        user = user or auth.user
        if auth:
            is_api_node = auth.api_node == self
        else:
            is_api_node = False
        return (
            (user and self.has_permission(user, 'write')) or is_api_node
        )

    # TODO: Remove save parameter
    def add_permission(self, user, permission, save=False):
        """Grant permission to a user.

        :param User user: User to grant permission to
        :param str permission: Permission to grant
        :param bool save: Save changes
        :raises: ValueError if user already has permission
        """

        if not self.has_permission(user, permission):
            self.get_group(permission).user_set.add(user)
        elif self.has_permission(user, permission):
            raise ValueError('User already has permission {0}'.format(permission))
        if save:
            self.save()

    # TODO: Remove save parameter
    def remove_permission(self, user, permission, save=False):
        """Revoke permission from a user.

        :param User user: User to revoke permission from
        :param str permission: Permission to revoke
        :param bool save: Save changes
        :raises: ValueError if user does not have permission
        """
        if self.get_group(permission).filter(user_id=user.id).exists():
            self.get_group(permission).user_set.remove(user)
        else:
            raise ValueError('User does not have permission {0}'.format(permission))
        if save:
            self.save()

    def clear_permissions(self, user):
        for name in self.group_names:
            if name == 'admin':
                if self.get_group('admin').user_set.exclude(id=user.id).exists():
                    self.remove_permission(user, 'admin')
                else:
                    raise PreprintStateError('Must have at least one registered admin contributor')
            self.remove_permission(user, name)

    def get_visible(self, user):
        try:
            contributor = self.preprintcontributor_set.get(user=user)
        except PreprintContributor.DoesNotExist:
            raise ValueError(u'User {0} not in contributors'.format(user))
        return contributor.visible

    @property
    def visible_contributors(self):
        return OSFUser.objects.filter(
            contributor__node=self,
            contributor__visible=True
        ).order_by('contributor___order')
