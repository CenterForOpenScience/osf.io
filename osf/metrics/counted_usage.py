from datetime import datetime
import enum
import logging
from urllib.parse import urlsplit

from elasticsearch6_dsl import InnerDoc, analyzer, tokenizer
from elasticsearch_metrics import metrics
from elasticsearch_metrics.signals import pre_save
from django.dispatch import receiver
import pytz

from osf.metrics.utils import stable_key
from osf.models import Guid


logger = logging.getLogger(__name__)

route_prefix_analyzer = analyzer(
    'route_prefix_analyzer',
    tokenizer=tokenizer('route_prefix_tokenizer', 'path_hierarchy', delimiter='.'),
)

class PageviewInfo(InnerDoc):
    """PageviewInfo

    for CountedAuthUsage generated by viewing a web page
    """
    # fields that should be provided
    referer_url = metrics.Keyword()
    page_url = metrics.Keyword()
    page_title = metrics.Keyword()
    route_name = metrics.Keyword(
        fields={
            'by_prefix': metrics.Text(analyzer=route_prefix_analyzer),
        },
    )

    # fields autofilled from the above (see `_autofill_fields`)
    page_path = metrics.Keyword()
    referer_domain = metrics.Keyword()
    hour_of_day = metrics.Integer()


class CountedAuthUsage(metrics.Metric):
    """CountedAuthUsage

    Something was used! Let's quickly take note of that and
    move on, then come back later to query/analyze/investigate.

    Aim to support a COUNTER-style reporting api
    (see https://cop5.projectcounter.org/en/5.0.2/)
    """

    # where noted, fields correspond to defined terms from COUNTER
    # https://cop5.projectcounter.org/en/5.0.2/appendices/a-glossary-of-terms.html
    platform_iri = metrics.Keyword()                  # counter:Platform
    provider_id = metrics.Keyword()                   # counter:Database(?)
    session_id = metrics.Keyword()                    # counter:Session
    item_guid = metrics.Keyword()                     # counter:Item
    item_type = metrics.Keyword()                     # counter:Data-Type
    surrounding_guids = metrics.Keyword(multi=True)   # counter:Title
    item_public = metrics.Boolean()                   # counter:Access-Type(?)
    user_is_authenticated = metrics.Boolean()

    action_labels = metrics.Keyword(multi=True)
    class ActionLabel(enum.Enum):
        SEARCH = 'search'       # counter:Search
        VIEW = 'view'           # counter:Investigation
        DOWNLOAD = 'download'   # counter:Request
        WEB = 'web'             # counter:Regular (aka "pageview")
        API = 'api'             # counter:TDM (aka "non-web api usage")
        # TODO: count api usage, distinguish between web and non-web api requests

    # pageviews get additional info to support the "node analytics" view
    # (see `api.metrics.views.NodeAnalyticsQuery`)
    pageview_info = metrics.Object(PageviewInfo)

    class Meta:
        dynamic = metrics.MetaField('strict')
        source = metrics.MetaField(enabled=True)


@receiver(pre_save, sender=CountedAuthUsage)
def _autofill_fields(sender, instance, **kwargs):
    pageview = getattr(instance, 'pageview_info', None)
    if pageview:
        _fill_pageview_info(instance)
    item_guid = getattr(instance, 'item_guid', None)
    if item_guid:
        guid_instance = Guid.load(item_guid)
        if guid_instance and guid_instance.referent:
            _fill_osfguid_info(instance, guid_instance.referent)
    _fill_document_id(instance)


def _fill_pageview_info(counted_usage):
    pageview = counted_usage.pageview_info
    pageview_dict = pageview.to_dict()
    pageview.hour_of_day = counted_usage.timestamp.hour
    pageview.page_path = urlsplit(pageview_dict['page_url']).path.rstrip('/')
    if referer := pageview_dict.get('referer_url'):
        pageview.referer_domain = urlsplit(referer).netloc


def _fill_osfguid_info(counted_usage, guid_referent):
    counted_usage.item_public = _get_ispublic(guid_referent)
    counted_usage.item_type = type(guid_referent).__name__.lower()
    counted_usage.surrounding_guids = _get_surrounding_guids(guid_referent)
    if not counted_usage.provider_id:
        counted_usage.provider_id = _get_provider_id(guid_referent)


def _fill_document_id(counted_usage):
    # set the document id to a hash of "unique together"
    # values to get "ON CONFLICT UPDATE" behavior -- if
    # a matching document already exists, it will be updated,
    # not duplicated.

    # cannot detect/avoid conflicts this way, but that's ok
    # because we want to approximate `counter:Double-Click Filtering`

    if counted_usage.pageview_info is not None and counted_usage.pageview_info.page_url is not None:
        target_identifier = counted_usage.pageview_info.page_url
    else:
        target_identifier = counted_usage.item_guid

    # slice the day into an array of 30-second windows,
    # find this timestamp's windowslice index
    day_start = datetime(
        counted_usage.timestamp.year,
        counted_usage.timestamp.month,
        counted_usage.timestamp.day,
        tzinfo=pytz.utc,
    )
    time_in_seconds = (counted_usage.timestamp - day_start).total_seconds()
    time_window = int(time_in_seconds / 30)

    counted_usage.meta.id = stable_key(
        # unique-together values:
        counted_usage.platform_iri,
        target_identifier,
        counted_usage.session_id,
        counted_usage.timestamp.date(),
        time_window,
    )


def _get_ispublic(guid_referent):
    # if it quacks like BaseFileNode, look at .target instead
    maybe_public = getattr(guid_referent, 'target', None) or guid_referent
    if hasattr(maybe_public, 'verified_publishable'):
        return maybe_public.verified_publishable        # quacks like Preprint
    return getattr(maybe_public, 'is_public', None)     # quacks like AbstractNode


def _get_provider_id(guid_referent):
    provider = getattr(guid_referent, 'provider', None)
    if isinstance(provider, str):
        return provider         # quacks like BaseFileNode
    elif provider:
        return provider._id     # quacks like Registration, Preprint, Collection
    return 'osf'                # quacks like Node, Comment, WikiPage


def _get_immediate_wrapper(guid_referent):
    if hasattr(guid_referent, 'verified_publishable'):
        return None                                     # quacks like Preprint
    return (
        getattr(guid_referent, 'parent_node', None)     # quacks like AbstractNode
        or getattr(guid_referent, 'node', None)         # quacks like WikiPage, Comment
        or getattr(guid_referent, 'target', None)       # quacks like BaseFileNode
    )

def _get_surrounding_guids(guid_referent):
    """get all the parent/owner/surrounding guids for the given guid_referent

    @param guid_referent: instance of a model that has GuidMixin
    @returns list of str

    For AbstractNode, goes up the node hierarchy up to the root.
    For WikiPage or BaseFileNode, grab the node it belongs to and
    follow the node hierarchy from there.
    """
    surrounding_guids = []
    current_referent = guid_referent
    while current_referent:
        next_referent = _get_immediate_wrapper(current_referent)
        if next_referent:
            surrounding_guids.append(next_referent._id)
        current_referent = next_referent
    return surrounding_guids
