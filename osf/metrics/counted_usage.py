from datetime import datetime
import enum
import logging
from urllib.parse import urlsplit

from elasticsearch_dsl import InnerDoc
from elasticsearch_metrics import metrics
from elasticsearch_metrics.signals import pre_save
from django.dispatch import receiver
import pytz

from osf.metrics.utils import stable_key
from osf.models import Guid


logger = logging.getLogger(__name__)


class PageviewInfo(InnerDoc):
    """PageviewInfo

    for CountedUsageV3 generated by viewing a web page
    """
    # fields that should be provided
    referer_url = metrics.Keyword()
    page_url = metrics.Keyword()
    page_title = metrics.Keyword()
    route_name = metrics.Keyword()  # TODO: analyze for filtering by prefix (split on '.')

    # fields autofilled from the above (see `autofill_fields`)
    page_path = metrics.Keyword()
    referer_domain = metrics.Keyword()
    hour_of_day = metrics.Integer()


class CountedUsageV3(metrics.Metric):
    """CountedUsageV3

    Something was used! Let's quickly take note of that and
    move on, then come back later to query/analyze/investigate.

    Aim to support a COUNTER-style reporting api
    (see https://cop5.projectcounter.org/en/5.0.2/)
    """

    # where noted, fields correspond to defined terms from COUNTER
    # https://cop5.projectcounter.org/en/5.0.2/appendices/a-glossary-of-terms.html
    platform_iri = metrics.Keyword()    # counter:Platform
    provider_id = metrics.Keyword()     # counter:Database
    session_id = metrics.Keyword()      # counter:Session
    item_guid = metrics.Keyword()       # counter:Item
    surrounding_guids = metrics.Keyword(multi=True)

    item_public = metrics.Boolean()

    action_labels = metrics.Keyword(multi=True)
    class ActionLabel(enum.Enum):
        SEARCH = 'search'       # counter:Search
        VIEW = 'view'           # counter:Investigation
        DOWNLOAD = 'download'   # counter:Request
        WEB = 'web'             # counter:Regular (aka "pageview")
        API = 'api'             # counter:TDM (aka "non-webclient api usage")
        # TODO: count api usage, distinguish between web and non-web api requests

    # pageviews get additional info to support the "node analytics" view
    # (see `api.metrics.views.NodeAnalyticsQuery`)
    pageview_info = metrics.Object(PageviewInfo)

    class Meta:
        dynamic = metrics.MetaField('strict')
        source = metrics.MetaField(enabled=True)


@receiver(pre_save, sender=CountedUsageV3)
def autofill_fields(sender, instance, **kwargs):
    counted_usage = instance
    pageview = getattr(counted_usage, 'pageview_info', None)
    if pageview:
        pageview.hour_of_day = counted_usage.timestamp.hour
        pageview.page_path = urlsplit(pageview.page_url).path.rstrip('/')
        referer = getattr(pageview, 'referer_url', None)
        if referer:
            pageview.referer_domain = urlsplit(referer).netloc

    # divide the day into 30-second windows, filter out
    # "double clicks" by removing duplicates within a window
    # (latest event wins, per COUNTER)
    day_start = datetime(
        counted_usage.timestamp.year,
        counted_usage.timestamp.month,
        counted_usage.timestamp.day,
        tzinfo=pytz.utc,
    )
    time_in_seconds = (counted_usage.timestamp - day_start).total_seconds()
    time_window = int(time_in_seconds / 30)

    guid = counted_usage.item_guid
    if guid:
        guid_instance = Guid.load(guid)
        if guid_instance:
            item = guid_instance.referent
            counted_usage.provider_id = get_provider_id(item)
            counted_usage.surrounding_guids = get_surrounding_guids(item)

    if pageview is not None:
        target_identifier = pageview.page_url
    else:
        target_identifier = counted_usage.item_guid

    # Set the document id to a hash of "unique together"
    # values to get "ON CONFLICT UPDATE" behavior -- if
    # the document already exists, it will be updated rather
    # than duplicated.  Cannot detect/avoid conflicts this way,
    # but that's ok because we want "doubleclick filtering"
    counted_usage.meta.id = stable_key(
        counted_usage.platform_iri,
        target_identifier,
        counted_usage.session_id,
        counted_usage.timestamp.date(),
        time_window,
    )


def get_provider_id(guid_referent):
    provider = getattr(guid_referent, 'provider', None)
    if isinstance(provider, str):
        return provider
    elif provider:
        return provider._id
    return getattr(guid_referent, 'provider_id', None)


def get_surrounding_guids(guid_referent):
    immediate_wrapper = (
        getattr(guid_referent, 'target', None)  # quacks like BaseFileNode
        or getattr(guid_referent, 'parent_node', None)  # quacks like AbstractNode
    )
    if immediate_wrapper:
        return [immediate_wrapper._id, *get_surrounding_guids(immediate_wrapper)]
    return []
