from datetime import datetime
import enum
import logging
from urllib.parse import urlsplit

from django.contrib.contenttypes.models import ContentType
from elasticsearch_dsl import InnerDoc, analyzer, tokenizer
from elasticsearch_metrics import metrics
from elasticsearch_metrics.signals import pre_save
from django.dispatch import receiver
import pytz

from osf.metrics.utils import stable_key
from osf.models import Guid


logger = logging.getLogger(__name__)

route_prefix_analyzer = analyzer(
    'route_prefix_analyzer',
    tokenizer=tokenizer('route_prefix_tokenizer', 'path_hierarchy', delimiter='.'),
)

class PageviewInfo(InnerDoc):
    """PageviewInfo

    for CountedUsageV5 generated by viewing a web page
    """
    # fields that should be provided
    referer_url = metrics.Keyword()
    page_url = metrics.Keyword()
    page_title = metrics.Keyword()
    route_name = metrics.Keyword(
        fields={
            'by_prefix': metrics.Text(analyzer=route_prefix_analyzer),
        },
    )

    # fields autofilled from the above (see `autofill_fields`)
    page_path = metrics.Keyword()
    referer_domain = metrics.Keyword()
    hour_of_day = metrics.Integer()


class CountedUsageV5(metrics.Metric):
    """CountedUsageV5

    Something was used! Let's quickly take note of that and
    move on, then come back later to query/analyze/investigate.

    Aim to support a COUNTER-style reporting api
    (see https://cop5.projectcounter.org/en/5.0.2/)
    """

    # where noted, fields correspond to defined terms from COUNTER
    # https://cop5.projectcounter.org/en/5.0.2/appendices/a-glossary-of-terms.html
    platform_iri = metrics.Keyword()                  # counter:Platform
    provider_id = metrics.Keyword()                   # counter:Database(?)
    session_id = metrics.Keyword()                    # counter:Session
    item_guid = metrics.Keyword()                     # counter:Item
    item_type = metrics.Keyword()                     # counter:Data-Type
    surrounding_guids = metrics.Keyword(multi=True)   # counter:Title
    item_public = metrics.Boolean()                   # counter:Access-Type(?)

    action_labels = metrics.Keyword(multi=True)
    class ActionLabel(enum.Enum):
        SEARCH = 'search'       # counter:Search
        VIEW = 'view'           # counter:Investigation
        DOWNLOAD = 'download'   # counter:Request
        WEB = 'web'             # counter:Regular (aka "pageview")
        API = 'api'             # counter:TDM (aka "non-webclient api usage")
        # TODO: count api usage, distinguish between web and non-web api requests

    # pageviews get additional info to support the "node analytics" view
    # (see `api.metrics.views.NodeAnalyticsQuery`)
    pageview_info = metrics.Object(PageviewInfo)

    class Meta:
        dynamic = metrics.MetaField('strict')
        source = metrics.MetaField(enabled=True)


@receiver(pre_save, sender=CountedUsageV5)
def autofill_fields(sender, instance, **kwargs):
    pageview = getattr(instance, 'pageview_info', None)
    if pageview:
        fill_pageview_info(instance, pageview)
    item_guid = getattr(instance, 'item_guid', None)
    if item_guid:
        guid_instance = Guid.load(item_guid)
        if guid_instance and guid_instance.referent:
            fill_osfguid_info(instance, guid_instance.referent)
    fill_document_id(instance)


def fill_pageview_info(counted_usage, pageview):
    pageview.hour_of_day = counted_usage.timestamp.hour
    pageview.page_path = urlsplit(pageview.page_url).path.rstrip('/')
    referer = getattr(pageview, 'referer_url', None)
    if referer:
        pageview.referer_domain = urlsplit(referer).netloc


def fill_osfguid_info(counted_usage, guid_referent):
    counted_usage.item_public = get_ispublic(guid_referent)
    counted_usage.item_type = ContentType.objects.get_for_model(
        guid_referent.__class__,
        for_concrete_model=False,
    ).model
    counted_usage.surrounding_guids = get_surrounding_guids(guid_referent)
    if not counted_usage.provider_id:
        counted_usage.provider_id = get_provider_id(guid_referent)


def fill_document_id(counted_usage):
    if counted_usage.pageview_info is not None:
        target_identifier = counted_usage.pageview_info.page_url
    else:
        target_identifier = counted_usage.item_guid

    # divide the day into 30-second windows, filter out
    # "double clicks" by removing duplicates within a window
    # (latest event wins, per COUNTER)
    day_start = datetime(
        counted_usage.timestamp.year,
        counted_usage.timestamp.month,
        counted_usage.timestamp.day,
        tzinfo=pytz.utc,
    )
    time_in_seconds = (counted_usage.timestamp - day_start).total_seconds()
    time_window = int(time_in_seconds / 30)

    # Set the document id to a hash of "unique together"
    # values to get "ON CONFLICT UPDATE" behavior -- if
    # the document already exists, it will be updated rather
    # than duplicated.  Cannot detect/avoid conflicts this way,
    # but that's ok because we want "doubleclick filtering"
    counted_usage.meta.id = stable_key(
        counted_usage.platform_iri,
        target_identifier,
        counted_usage.session_id,
        counted_usage.timestamp.date(),
        time_window,
    )


def get_ispublic(guid_referent):
    # if it quacks like BaseFileNode, look at .target instead
    maybe_public = getattr(guid_referent, 'target', guid_referent)
    return bool(
        getattr(maybe_public, 'verified_publishable', None)  # quacks like Preprint
        or getattr(maybe_public, 'is_public', None)          # quacks like AbstractNode
    )


def get_provider_id(guid_referent):
    provider = getattr(guid_referent, 'provider', None)
    if isinstance(provider, str):
        return provider
    elif provider:
        return provider._id
    return getattr(guid_referent, 'provider_id', None)


def get_surrounding_guids(guid_referent):
    immediate_wrapper = (
        getattr(guid_referent, 'target', None)  # quacks like BaseFileNode
        or getattr(guid_referent, 'parent_node', None)  # quacks like AbstractNode
    )
    if immediate_wrapper:
        return [immediate_wrapper._id, *get_surrounding_guids(immediate_wrapper)]
    return []
