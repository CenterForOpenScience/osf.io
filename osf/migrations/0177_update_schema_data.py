# -*- coding: utf-8 -*-
# Generated by Django 1.11.13 on 2018-09-26 20:08
from __future__ import unicode_literals

from django.db import migrations
from osf.models.base import generate_object_id

FORMAT_TYPE_TO_TYPE_MAP = {
    ('multiselect', 'choose'): 'multi-select-input',
    (None, 'multiselect'): 'multi-select-input',
    (None, 'choose'): 'single-select-input',
    ('osf-upload-open', 'osf-upload'): 'file-input',
    ('osf-upload-toggle', 'osf-upload'): 'file-input',
    ('singleselect', 'choose'): 'single-select-input',
    ('text', 'string'): 'short-text-input',
    ('textarea', 'osf-author-import'): 'contributors-input',
    ('textarea', 'string'): 'long-text-input',
    ('textarea-lg', None): 'long-text-input',
    ('textarea-lg', 'string'): 'long-text-input',
    ('textarea-xl', 'string'): 'long-text-input',
}

def remove_version_1_schemas(state, schema):
    RegistrationSchema = state.get_model('osf', 'registrationschema')
    assert RegistrationSchema.objects.filter(schema_version=1, abstractnode__isnull=False).count() == 0
    assert RegistrationSchema.objects.filter(schema_version=1, draftregistration__isnull=False).count() == 0
    RegistrationSchema.objects.filter(schema_version=1).delete()

def update_schemaless_registrations(state, schema):
    RegistrationSchema = state.get_model('osf', 'registrationschema')
    AbstractNode = state.get_model('osf', 'abstractnode')

    open_ended_schema = RegistrationSchema.objects.get(name='Open-Ended Registration')
    open_ended_meta = {
        '{}'.format(open_ended_schema._id): {
            'summary': {
                'comments': [],
                'extra': [],
                'value': ''
            }
        }
    }

    schemaless_regs_with_meta = AbstractNode.objects.filter(type='osf.registration', registered_schema__isnull=True).exclude(registered_meta={})
    schemaless_regs_without_meta = AbstractNode.objects.filter(type='osf.registration', registered_schema__isnull=True, registered_meta={})

    for reg in schemaless_regs_without_meta.all():
        reg.registered_schema.add(open_ended_schema)
        reg.registered_meta = open_ended_meta
        reg.save()

    for reg in schemaless_regs_with_meta.all():
        reg.registered_schema.add(RegistrationSchema.objects.get(_id=reg.registered_meta.keys()[0]))

def update_schema_configs(state, schema):
    RegistrationSchema = state.get_model('osf', 'registrationschema')
    # TODO, factor in AsPredictedSchema, version 3
    for rs in RegistrationSchema.objects.filter(schema_version=2):
        if rs.schema.get('description', False):
            rs.description = rs.schema['description']
        rs.save()

def unset_schema_configs(state, schema):
    RegistrationSchema = state.get_model('osf', 'registrationschema')
    RegistrationSchema.objects.update(config=dict())

def unmap_formblocks(state, schema):
    RegistrationFormBlock = state.get_model('osf', 'registrationformblock')
    RegistrationFormBlock.objects.all().delete()

def noop(*args, **kwargs):
    pass

def create_block(state, schema_id, block_type, display_text='', required=False, help_text='',
        answer_id='', chunk_id=''):
    RegistrationFormBlock = state.get_model('osf', 'registrationformblock')

    return RegistrationFormBlock.objects.create(
        schema_id=schema_id,
        block_type=block_type,
        required=required,
        display_text=display_text,
        help_text=help_text,
        answer_id=answer_id,
        chunk_id=chunk_id,
    )

# Split question multiple choice options into blocks
def split_options_into_blocks(state, rs, question, chunk_id):
    for option in question.get('options', []):
        answer_text = option if isinstance(option, basestring) else option.get('text')
        help_text = '' if isinstance(option, basestring) else option.get('tooltip', '')

        if 'other' in answer_text.lower():
            create_block(
                state,
                rs.id,
                'select-other-option',
                display_text=answer_text,
                help_text=help_text,
                chunk_id=chunk_id
            )
        else:
            create_block(
                state,
                rs.id,
                'select-input-option',
                display_text=answer_text,
                help_text=help_text,
                chunk_id=chunk_id,
            )

def get_answer_id(question):
    return question.get('qid', '') or question.get('id', '')

def find_title_description_help(question):
    title = question.get('title', '')
    description = question.get('description', '')
    help = question.get('help', '')
    help_text_keywords = ['please', 'choose', 'provide']

    if title:
        for keyword in help_text_keywords:
            if keyword in description.lower():
                help = description
                description = ''
    else:
        title = description
        description = ''

    return title, description, help


def format_question(state, rs, question, sub=False):
    # If there are subquestions, recurse and format subquestions
    if question.get('properties'):
        # Creates section or subsection
        create_block(
            state,
            rs.id,
            block_type='subsection-heading' if sub else 'section-heading',
            display_text=question.get('title', '') or question.get('description', ''),
        )
        for property in question.get('properties'):
            property['qid'] = '{}.{}'.format(get_answer_id(question), property.get('id', ''))
            format_question(state, rs, property, sub=True)
    else:
        chunk_id = generate_object_id()
        title, description, help = find_title_description_help(question)

        # Creates question title block
        create_block(
            state,
            rs.id,
            block_type='question-title',
            display_text=title,
            help_text='' if description else help,
            chunk_id=chunk_id
        )

        # Creates paragraph block (question description)
        if description:
            create_block(
                state,
                rs.id,
                block_type='paragraph',
                display_text=description,
                help_text=help,
                chunk_id=chunk_id,
            )

        # Creates question input block - this block will correspond to an answer
        # Map the original schema section format to the new block_type, and create a schema block
        block_type = FORMAT_TYPE_TO_TYPE_MAP[(question.get('format'), question.get('type'))]
        create_block(
            state,
            rs.id,
            block_type,
            required=question.get('required', False),
            chunk_id=chunk_id,
            answer_id=get_answer_id(question)
        )

        # If there are multiple choice answers, create blocks for these as well.
        split_options_into_blocks(state, rs, question, chunk_id)


def map_schema_to_formblocksv2(state, schema):
    RegistrationSchema = state.get_model('osf', 'registrationschema')
    # Returns the latest version of all visible schemas (?) inactive are still included.
    # How to handle EGAP schema?
    schemas = RegistrationSchema.objects.filter(visible=True).order_by('name', '-schema_version').distinct('name')
    for rs in schemas:
        for page in rs.schema['pages']:
            # Create page block
            create_block(
                state,
                rs.id,
                'page-heading',
                display_text=page.get('title', ''),
                help_text=page.get('description', '')
            )
            for question in page['questions']:
                format_question(state, rs, question)


class Migration(migrations.Migration):

    dependencies = [
        ('osf', '0176_alter_form_blocks_v2'),
    ]

    operations = [
        migrations.RunPython(remove_version_1_schemas, noop),
        migrations.RunPython(update_schemaless_registrations, noop),
        migrations.RunPython(update_schema_configs, unset_schema_configs),
        migrations.RunPython(map_schema_to_formblocksv2, unmap_formblocks)
    ]
